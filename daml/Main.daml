module Main where

import qualified Daml.Script as S
import Daml.Trigger
import DA.Foldable (forA_)
import qualified DA.Optional as Optional
import qualified DA.Map as Map
import DA.Functor (void)
import DA.Time

template Cat
  with
    owner : Party
    isin : Int
  where
    signatory owner
    key this : Cat
    agreement "is not empty"
    maintainer key.owner

    choice Feed : ()
      with
       foodCid : ContractId Food
      controller owner
      do
        exercise foodCid Food_FeedCat

template Food
  with
    owner : Party
    isin : Int
  where
    signatory owner
    key this : Food
    maintainer key.owner

    choice Food_FeedCat : ()
      controller owner
      do
        pure ()

template Counter
  with
    owner: Party
    id: Text
    i: Int
  where
    signatory owner
    key (owner, id) : (Party, Text)
    maintainer key._1
    choice CounterUpdate : ()
      with j : Int
        controller owner
        do
          create $ this with i = j
          pure ()

template Lock
  with
    owner: Party
  where
    signatory owner
    key owner : Party
    maintainer key

template Helper
  with
    owner: Party
  where
    signatory owner

    choice Cats: ()
      controller owner
      do
        forA_ (ints n) \i -> do
          l <- lookupByKey @Cat (Cat owner i)
          case l of
            None -> void $ create (Cat owner i)
            Some _ -> pure ()

    choice Foods: ()
      controller owner
       do
        forA_ (ints n) \i -> do
          l <- lookupByKey @Food (Food owner i)
          case l of
            None -> void $ create (Food owner i)
            Some _ -> pure ()

    choice Eat: ()
      with i : Int
      controller owner
      do
        r <- lookupByKey @Food (Food owner i)
        case r of
          None -> pure ()
          Some _ -> do
            exerciseByKey @Food (Food owner i) Archive

    choice EatAll: ()
      controller owner
      do
        forA_ (ints n) \i ->  do

          r <- lookupByKey @Food (Food owner i)
          case r of
            None -> pure ()
            Some _ ->
              do
                exerciseByKey @Food (Food owner i) Archive

trigger : Trigger Int
trigger = Trigger
  { initialize = pure 0
  , updateState = countTransaction
  , rule = feedTheCats
  , registeredTemplates =  RegisteredTemplates [ registeredTemplate @Cat, registeredTemplate @Food, registeredTemplate @Lock ]
  , heartbeat = None
  }

data State =
    Failure
  | WaitUntil Time
  | OK

delay = seconds 2

adaptRule:  (Party -> TriggerA State ()) -> Party -> TriggerA State ()
adaptRule rule party =
  get >>= \case
    Failure -> do
      t <- getTime
      put $ WaitUntil $ t `addRelTime` delay
    WaitUntil t1 -> do
      t2 <- getTime
      if (t2 < t1) then
        debugRaw $ "cats: skip"
      else do
        rule party
        put OK
    OK ->
      rule party

update: Message -> TriggerUpdateA State ()
update (MCompletion (Completion _ Failed {})) = put Failure
update MHeartbeat = debugRaw $ "cats: heartbeat received"
update (MTransaction _) = debugRaw $ "cats: transaction received"
update (MCompletion _) = debugRaw $  "cats: completion received"


trigger2 : Trigger State
trigger2 = Trigger
  { initialize = pure OK
  , updateState = update
  , rule = adaptRule feedTheCats
  , registeredTemplates =  RegisteredTemplates [ registeredTemplate @Cat, registeredTemplate @Food, registeredTemplate @Lock ]
  , heartbeat = Some (seconds 20)
  }


limit = 100
n = 500

ints : Int -> [Int]
ints 0 = []
ints n = n :: ints (n - 1)

skipIfTooManyCommandsInFlight: a -> (TriggerA s a) -> (TriggerA s a)
skipIfTooManyCommandsInFlight otherwise action  = do
  cs <- getCommandsInFlight
  if Map.size cs >= limit then
    pure otherwise
  else
    action

skipIfLock: a -> (TriggerA s a) -> (TriggerA s a)
skipIfLock otherwise action = do
  locks <- query @Lock
  if (length locks > 0) then
    pure otherwise
  else
    action

for_ : [a] -> (a -> TriggerA c b) -> TriggerA c ()
for_ (h :: t) f =
  skipIfTooManyCommandsInFlight () $ do
      f h
      for_ t f
for_ _ _ = pure ()

countTransaction: Message -> TriggerUpdateA Int ()
countTransaction (MTransaction _) = do
  i <- get
  debugRaw $ "Saw a total of " <> show (i+1) <> " transactions until now"
  put (i+1)
countTransaction _ = pure ()

feedTheCats: Party -> TriggerA s ()
feedTheCats _ = do
  cats <- query @Cat
  foods <- query @Food
  locks <- query @Lock
  cs <- getCommandsInFlight
  debugRaw $ "Feeding " <> show (length cats) <> " cats with " <> show (length foods) <> " foods (" <> show (Map.size cs) <>  ")"
  skipIfLock () $
    for_ cats \(catCid, Cat{..}) -> do
      queryContractKey @Food (Food owner isin) >>= \case
        Some (foodCid, _) ->
          void $ emitCommands [exerciseCmd catCid (Feed foodCid)] [toAnyContractId catCid, toAnyContractId foodCid]
        None ->
          pure ()


setup : S.Script ()
setup = S.script do
-- user_setup_begin
  alice <- S.allocatePartyWithHint "Alice" (S.PartyIdHint "Alice")
  aliceId <- S.validateUserId "alice"
  _ <- S.createUser (S.User aliceId (Some alice)) [S.CanActAs alice]
  init

string2Party party =  do
   userId <- S.validateUserId party
   user <- S.getUser userId
   pure $ Optional.fromSome user.primaryParty

init : S.Script ()
init = do
  alice <- string2Party "alice"
  _ <- S.submit alice $ S.createCmd $ Lock alice
  _ <- S.submit alice $ S.createAndExerciseCmd (Helper alice) Cats
  _ <- S.submit alice $ S.createAndExerciseCmd (Helper alice) Foods
  pure ()

eatAll : S.Script ()
eatAll = S.script do
  alice  <- string2Party "alice"
  _ <-  S.submit alice $ S.exerciseByKeyCmd @Lock alice Archive
  forA_ (ints n) \i ->  do
    S.submit alice $ S.createAndExerciseCmd (Helper alice) (Eat i)
